= Hystrix 소개하기

https://github.com/Netflix/Hystrix/wiki[Hystrix 위키의 홈]에서 설명하는 소개글입니다. 

== Hystrix란 무엇인가? 
분산환경에서는 불가피한 많은 서비스 의존성이 실패 원이이 될 것이다. 히스트릭스는 latency tolerance와 fault tolerance를 통해서 이러한 분산 서비스 간에 상호 작용 제어를 도와주는 라이브러리다. 히스트릭스는 (1) 서비스 간의 접근 지점을 고립시키고, 상호 작용을 통해 계속 전파되는 장애를 막아주며, 폴백 옵션을 제공해 시스템의 평균적인 resiliency 향상으로 모두 이를 해낸다. 

=== 히스트릭스 역사 
히스트릭스는 2011에 시작한 넷플릭스 API 팀이 resilience 엔지니어링 작업 과정 중에 만들었다. 2012에도 히스트릭스 계속 발전했고 성숙했고 넷플릭스 안의 많은 팀이 이를 적용했다. 오늘날 수백억의 쓰레드-고립되고, 수천억의 세마포어-고립된 호출이 넷플릭스에서 매일 히스트릭스를 통해 실행된다. 이건 가동시간(uptime)과 resilience에 대한 극적인 향상을 가지고 왔다. 

다음 링크는 히스트릭스에 대한 더 많은 정황(상황? context..)과 문제를 다루기 위해 시도할 때의 도전을 알려준다. 

- http://techblog.netflix.com/2011/12/making-netflix-api-more-resilient.html["넷플릭스 API를 더 resilient하게 만들기"]
- http://techblog.netflix.com/2012/02/fault-tolerance-in-high-volume.html["고용량 분산 시스템에서 fault tolerance"]
- https://speakerdeck.com/benjchristensen/performance-and-fault-tolerance-for-the-netflix-api-august-2012["넷플릭스 API의 성능과 fault tolerance"]
- http://programming.oreilly.com/2013/06/application-resilience-in-a-service-oriented-architecture.html["서비스 지향 아키텍처에서 애플리케이션 resilience"]
- https://speakerdeck.com/benjchristensen/application-resilience-engineering-and-operations-at-netflix["넷플릭스에서 애플리케이션 resilience 엔지니어링과 운영"]

== 히스트릭스란 무엇인가? 
히스트릭스는 다음을 실행하고자 설계됐다. 

- 써드파티 클라이언트 라이브러리를 통해 접근하는 의존성에서 대기시간(latency)과 장애에서 보호하고 제어해줌 
- 복잡한 분산 시스템에서 실패가 전파되는 걸 막음 
- 빨리 실패하고 신속히 복구하기 
- 가능하다면 폴백과 우아하게 저하시키기(? 분해하기?) 
- 거의 실시간 모니터링, 알람, 운영 통제 가능하게 하기 

== 히스트릭스는 어떤 문제를 해결해주는가? 
복잡한 분산 아키텍처에서 애플리케이션은 많은 의존성을 갖게되며, 각각은 어떤 지점에서(순간에?) 불가피하게 실패가 발생할 것이다. 호스트(주인?) 애플리케이션이 이러한 외부 실패에서  고립되어 있지 않는다면 it risks being taken down with them.

예를 들어, 99.99% 가동시간을 갖는 30개 서비스에 의존성을 갖는 애플리케이션이 있을 때, 다음을 기대할 수 있을 것이다. 

> 99.9930 = 99.7% 가동시간 
> 십억 요청의 0.3% = 3,000,000 실패 
> 모든 의존성이 최상의 가동시간을 보여준다고 해도 매달 2 시간 이상의 다운시간 

현실은 보통 더 나쁘다. 

심지어 모든 의존성이 잘 수행할 때 수 십개의 서비스 각각에서 일어나는  0.001% 다운타임이라도 잠재적으로 한 달에 몇 시간의 다운타임과 같다. 전체 시스템에 대한 resilience를 엔지니어링 하지 않았다면 말이다. 

모두 정상적인 경우 요청 흐름은 다음과 같이 보일 것이다. 

https://github.com/Netflix/Hystrix/wiki/images/soa-1-640.png

많은 백엔드 시스템 중 하나가 지연을 보이면 전체 사용자 요청을 막을 수 있다. 

https://github.com/Netflix/Hystrix/wiki/images/soa-2-640.png

고용량 트래픽과 함께라면 하나의 백엔드 의존성 지연으로도 모든 서버에서 몇 초간 모든 리소스가 흠뻑 젖는(?) 원인이 될 수 있다. 

네트워크 요청을 야기하는 네트워크를 통해서나 클라이언트 라이브러리를 통해서 도달하는 애플리케이션의 모든 지점이 잠재적인 장애의 원인이 된다. 장애보다 더 나쁜건 이러한 애플리케이션이 서비스, 쓰레드, 그리고 다른 시스템 자원 사이의 대기시간을 증가시켜서시스템에 영향을 미쳐 장애가 훨씬 더 전파되는 원인이 될 수 있다는 점이다.  (**which backs up queues**?)

https://github.com/Netflix/Hystrix/wiki/images/soa-3-640.png

이러한 이슈는 네트워크 접근이 써드파티 클라리언트를 통해서 수행될 때 악화된다. 상세한 구현이 "블랙박스"로 숨겨져 있고, 언제든지 변경될 수 있으며, 네트워크나 리소스 구성이각 클라이언트 라이브러리 마다 달라서 대부분 모니터링하거나 변경하기 어렵다. 

더 심각한 건 애플리케이션에서 명확하게 호출하지 않고 잠재적으로 비싸거나 결함이 발생하기 쉬운 네트워크 호출 수행하는  transitive 의존성(transitive dependencies)다. 

네트워크 연결은 실패하거나 분해된다(?). 서비스와 서버는 실패하거나 느려진다. 새로운 라이브러리나 서비스 배포는 행동과 성능 특성을 변화시킨다. 클라이언트 라이브러리는 버그를 갖고 있다. 

이들 모두는 고립되야 하고 관리되야 할 필요가 있는 장애와 대기시간을 대표한다. 장애가 발생한 하나의 의존성이 전체 애플리케이션이나 시스템을 다운시키지 못하도록 말이다. 

== 히스트릭스의 기저를 이루는 디자인 원칙은 무엇일까? 
히스트릭스는 다음에 따라 동작한다: 

- 어떤 단일 의존성에서 모든 컨테이너(톰캣과 같은) 사용자 쓰레드를 다 써버리는 것을 예방한다. 
- 큐 처리 대신에 부하를 발산(Shedding?)하고 빨리 실패하기 
- 장애에서 사용자를 보호하는 어디서든지(wherever?) 실현가능한 폴백 제공하기 
- 모든 하나의 의존성의 영향을 제한하기 위해 격리 기술 사용하기 (bulkhead, swimlane과 써킷 브레이커(circuit breaker) 패턴)
- 근 실시간(더 좋은 표현은? near real-time) 메트릭스, 모니터링, 알람을 통해 time-to-discovery 최적화하기 
- **대게 히스트릭스의 양상으로** 구성 변경의 낮은 지연시간 전파(propagation?)와 동적 프로퍼티 변경 지원에 의해 time-to-discovery 최적화하기. 낮은 지연시간을 보여주는 피드백 반복으로 실시간 운영 상에서 수정을 가능하게 해준다. 
- 네트워크 트래픽 뿐만이 아니라 전체 의존성 클라이언트 실행의 장애에 맞서 보호해주기 

== 히스트릭스는 어떻게 이 목적을 달성하는가? 

히스트릭스는 다음을 한다: 

- HystrixCommand나 HystrixObservableCommand 객체에서 외부 시스템(또는 "의존성")으로 나가는 모든 호출을 감싼다. 이 두 객체는 일반적으로 다른 쓰레드 안에서 실행한다(이 객체는 https://en.wikipedia.org/wiki/Command_pattern[커맨드 패턴]의 일례다). 
- 정의한 임계치(thresholds)보다 더 오래걸리는 호출은 타임아웃시킨다. 타임아웃이 기본이지만 대부분 의존성은 "properties"에 의해서 이 타임아웃을 커스텀 설정을 한다. 각각의 의존성에 대해 측정한 99.5th 백분위수 성능보다 약간은 더 높게 하기 위함이다. (다시 정밀하게 해석 필요) 
- 각 의존성에 대해 작은 쓰레드 풀(또는 세마포어)를 유지하기. 쓰레드 풀이 가득차면 해당 의존성에 대해 운명(destined?)적인 요청은 큐로 들어가는 대신에 즉각 거절당한다. 
- 성공, 실패(클라이언트에 의해서 던져진 예외), 타임아웃, 쓰레드 거절 측정하기
- 일정 시간 동안(for a period of time?) 특정 서비스에 대한 모든 요청을 멈추고자 써킷 브레이커 tripping. 서비스에서 에러 퍼센트가 임계치를 넘었을 경우 수동이나 자동으로
- 요청이 실패하거나 거절당하거나 타임아웃됐거나 짧은 서킷이 발생했을 때 폴백 로직 수행하기 
- 근 실시간으로  메트릭스와 구성 변경 모니터링하기 

각 근본이 되는 의존성을 감싸기 위해 히스트릭스를 사용할 때 다음 다이어그램과 유사하게 변경보다 위로 다이어그램에서 보여주는 아키텍처다(위 그림과 비교?). 각 의존성은 다른 의존성에서 격리되었고, 리소스에 대해 제약되었고 ...

https://github.com/Netflix/Hystrix/wiki/images/soa-4-isolation-640.png

https://github.com/Netflix/Hystrix/wiki/How-it-Works[동작 방식]과 https://github.com/Netflix/Hystrix/wiki/How-To-Use[사용 방법]에 대해 더 배워보자 